initSidebarItems({"enum":[["BinaryOffset",""],["BoolOffset",""],["DateOffset",""],["DateUnit",""],["DecimalOffset",""],["DictionaryEncodingOffset",""],["DictionaryKind","---------------------------------------------------------------------- Dictionary encoding metadata Maintained for forwards compatibility, in the future Dictionaries might be explicit maps between integers and values allowing for non-contiguous index values"],["DurationOffset",""],["Endianness","---------------------------------------------------------------------- Endianness of the platform producing the data"],["FieldOffset",""],["FixedSizeBinaryOffset",""],["FixedSizeListOffset",""],["FloatingPointOffset",""],["IntOffset",""],["IntervalOffset",""],["IntervalUnit",""],["KeyValueOffset",""],["LargeBinaryOffset",""],["LargeListOffset",""],["LargeUtf8Offset",""],["ListOffset",""],["MapOffset",""],["MetadataVersion",""],["NullOffset",""],["Precision",""],["SchemaOffset",""],["Struct_Offset",""],["TimeOffset",""],["TimeUnit",""],["TimestampOffset",""],["Type","---------------------------------------------------------------------- Top-level Type value, enabling extensible type-specific metadata. We can add new logical types to Type without breaking backwards compatibility"],["UnionMode",""],["UnionOffset",""],["Utf8Offset",""]],"fn":[["enum_name_date_unit",""],["enum_name_dictionary_kind",""],["enum_name_endianness",""],["enum_name_interval_unit",""],["enum_name_metadata_version",""],["enum_name_precision",""],["enum_name_time_unit",""],["enum_name_type",""],["enum_name_union_mode",""],["finish_schema_buffer",""],["finish_size_prefixed_schema_buffer",""],["get_root_as_schema",""],["get_size_prefixed_root_as_schema",""]],"struct":[["Binary","Opaque binary data"],["BinaryArgs",""],["BinaryBuilder",""],["Bool",""],["BoolArgs",""],["BoolBuilder",""],["Buffer","---------------------------------------------------------------------- A Buffer represents a single contiguous memory segment"],["Date","Date is either a 32-bit or 64-bit type representing elapsed time since UNIX epoch (1970-01-01), stored in either of two units:"],["DateArgs",""],["DateBuilder",""],["Decimal",""],["DecimalArgs",""],["DecimalBuilder",""],["DictionaryEncoding",""],["DictionaryEncodingArgs",""],["DictionaryEncodingBuilder",""],["Duration",""],["DurationArgs",""],["DurationBuilder",""],["Field","---------------------------------------------------------------------- A field represents a named column in a record / row batch or child of a nested type."],["FieldArgs",""],["FieldBuilder",""],["FixedSizeBinary",""],["FixedSizeBinaryArgs",""],["FixedSizeBinaryBuilder",""],["FixedSizeList",""],["FixedSizeListArgs",""],["FixedSizeListBuilder",""],["FloatingPoint",""],["FloatingPointArgs",""],["FloatingPointBuilder",""],["Int",""],["IntArgs",""],["IntBuilder",""],["Interval",""],["IntervalArgs",""],["IntervalBuilder",""],["KeyValue","---------------------------------------------------------------------- user defined key value pairs to add custom metadata to some key namespacing is the responsibility of the user"],["KeyValueArgs",""],["KeyValueBuilder",""],["LargeBinary","Same as Binary, but with 64-bit offsets, allowing to represent extremely large data values."],["LargeBinaryArgs",""],["LargeBinaryBuilder",""],["LargeList","Same as List, but with 64-bit offsets, allowing to represent extremely large data values."],["LargeListArgs",""],["LargeListBuilder",""],["LargeUtf8","Same as Utf8, but with 64-bit offsets, allowing to represent extremely large data values."],["LargeUtf8Args",""],["LargeUtf8Builder",""],["List",""],["ListArgs",""],["ListBuilder",""],["Map","A Map is a logical nested type that is represented as"],["MapArgs",""],["MapBuilder",""],["Null","These are stored in the flatbuffer in the Type union below"],["NullArgs",""],["NullBuilder",""],["Schema","---------------------------------------------------------------------- A Schema describes the columns in a row batch"],["SchemaArgs",""],["SchemaBuilder",""],["Struct_","A Struct_ in the flatbuffer metadata is the same as an Arrow Struct (according to the physical memory layout). We used Struct_ here as Struct is a reserved word in Flatbuffers"],["Struct_Args",""],["Struct_Builder",""],["Time","Time type. The physical storage type depends on the unit - SECOND and MILLISECOND: 32 bits - MICROSECOND and NANOSECOND: 64 bits"],["TimeArgs",""],["TimeBuilder",""],["Timestamp","Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding leap seconds, as a 64-bit integer. Note that UNIX time does not include leap seconds."],["TimestampArgs",""],["TimestampBuilder",""],["TypeUnionTableOffset",""],["Union","A union is a complex type with children in Field By default ids in the type vector refer to the offsets in the children optionally typeIds provides an indirection between the child offset and the type id for each child typeIds[offset] is the id used in the type vector"],["UnionArgs",""],["UnionBuilder",""],["Utf8","Unicode with UTF-8 encoding"],["Utf8Args",""],["Utf8Builder",""]]});